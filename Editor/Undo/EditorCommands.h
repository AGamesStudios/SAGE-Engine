#pragma once
#include <memory>
#include <vector>
#include <string>
#include <optional>
#include "EditorScene.h"

namespace SAGE { namespace Editor {

class IEditorCommand { public: virtual ~IEditorCommand() = default; virtual void Execute(EditorScene&) = 0; virtual void Undo(EditorScene&) = 0; virtual std::string GetName() const = 0; };
using CommandPtr = std::unique_ptr<IEditorCommand>;

class CreateEntityCommand : public IEditorCommand { public: explicit CreateEntityCommand(std::string nameHint) : m_NameHint(std::move(nameHint)) {} void Execute(EditorScene& scene) override { m_Entity = scene.CreateEntity(m_NameHint); } void Undo(EditorScene& scene) override { if (ECS::IsValid(m_Entity)) scene.DestroyEntity(m_Entity); } std::string GetName() const override { return "CreateEntity"; } ECS::Entity GetEntity() const { return m_Entity; } private: std::string m_NameHint; ECS::Entity m_Entity = ECS::NullEntity; };
class DeleteEntityCommand : public IEditorCommand { public: explicit DeleteEntityCommand(ECS::Entity e) : m_Entity(e) {} void Execute(EditorScene& scene) override { if (!m_Snapshot && ECS::IsValid(m_Entity)) { if (auto* t = scene.GetTransform(m_Entity)) m_Transform = *t; if (auto* s = scene.GetSprite(m_Entity)) m_Sprite = *s; if (auto* rec = scene.FindRecord(m_Entity)) m_Name = rec->name; m_Snapshot = true; } scene.DestroyEntity(m_Entity); } void Undo(EditorScene& scene) override { if (!m_Snapshot) return; ECS::Entity restored = scene.CreateEntity(m_Name); if (auto* t = scene.GetTransform(restored)) *t = m_Transform; if (auto* s = scene.GetSprite(restored)) *s = m_Sprite; m_Entity = restored; } std::string GetName() const override { return "DeleteEntity"; } private: ECS::Entity m_Entity; bool m_Snapshot = false; std::string m_Name; ECS::TransformComponent m_Transform{}; ECS::SpriteComponent m_Sprite{}; };
class RenameEntityCommand : public IEditorCommand { public: RenameEntityCommand(ECS::Entity e, std::string newName) : m_Entity(e), m_New(std::move(newName)) {} void Execute(EditorScene& scene) override { if (auto* rec = scene.FindRecord(m_Entity)) { if (!m_Old) m_Old = rec->name; scene.RenameEntity(m_Entity, m_New); } } void Undo(EditorScene& scene) override { if (m_Old) scene.RenameEntity(m_Entity, *m_Old); } std::string GetName() const override { return "RenameEntity"; } private: ECS::Entity m_Entity; std::string m_New; std::optional<std::string> m_Old; };
class TransformChangeCommand : public IEditorCommand { public: TransformChangeCommand(ECS::Entity e, const ECS::TransformComponent& before, const ECS::TransformComponent& after) : m_Entity(e), m_Before(before), m_After(after) {} void Execute(EditorScene& scene) override { if (auto* t = scene.GetTransform(m_Entity)) *t = m_After; } void Undo(EditorScene& scene) override { if (auto* t = scene.GetTransform(m_Entity)) *t = m_Before; } std::string GetName() const override { return "TransformChange"; } private: ECS::Entity m_Entity; ECS::TransformComponent m_Before; ECS::TransformComponent m_After; };
class SpriteChangeCommand : public IEditorCommand { public: SpriteChangeCommand(ECS::Entity e, const ECS::SpriteComponent& before, const ECS::SpriteComponent& after) : m_Entity(e), m_Before(before), m_After(after) {} void Execute(EditorScene& scene) override { if (auto* s = scene.GetSprite(m_Entity)) *s = m_After; } void Undo(EditorScene& scene) override { if (auto* s = scene.GetSprite(m_Entity)) *s = m_Before; } std::string GetName() const override { return "SpriteChange"; } private: ECS::Entity m_Entity; ECS::SpriteComponent m_Before; ECS::SpriteComponent m_After; };
class UndoStack { public: void Push(CommandPtr cmd, EditorScene& scene) { if (m_Index < m_Commands.size()) m_Commands.erase(m_Commands.begin() + m_Index, m_Commands.end()); cmd->Execute(scene); m_Commands.push_back(std::move(cmd)); ++m_Index; } bool CanUndo() const { return m_Index > 0; } bool CanRedo() const { return m_Index < m_Commands.size(); } void Undo(EditorScene& scene) { if (!CanUndo()) return; --m_Index; m_Commands[m_Index]->Undo(scene); } void Redo(EditorScene& scene) { if (!CanRedo()) return; m_Commands[m_Index]->Execute(scene); ++m_Index; } void Clear() { m_Commands.clear(); m_Index = 0; } private: std::vector<CommandPtr> m_Commands; size_t m_Index = 0; };
} } // namespace SAGE::Editor
